<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programs on Fanstasy Player / 幻想系玩家</title>
    <link>https://fantasyplayer.link/program/</link>
    <description>Recent content in Programs on Fanstasy Player / 幻想系玩家</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 02 May 2021 16:41:53 +0800</lastBuildDate>
    
	<atom:link href="https://fantasyplayer.link/program/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>自制脚本语言[5.1] if-else分支语句</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%805.1-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Sun, 02 May 2021 16:41:53 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%805.1-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</guid>
      <description>本篇来尝试描述下if-else语句如何进行实现。
基本内容 语法树部分 先掏出之前给读者看过的这张图， 然后笔者来解释一下其中的内容。
显而易见， 左侧部分是源代码， 右侧部分是一个大致的AST图示。
前两个部分就是一个赋值语句， 一个声明语句。 没什么好描述的。
由图示可知下面的内容。
 把if-else 语句 拆分成了一个单独的if语句和一个单独的else语句 把if语句继续拆分成一个condition部分，一个执行代码块部分。 所以我们现在就有了三个小部分。  if.condition if的 条件部分 if.block if的代码块部分 else else 语句的代码块部分   这三个小块的逻辑也比较简单。 if.condition == true的时候执行if.block 否则执行else  直接在AST上进行运算 如果像现在的langX一样直接在语法树上进行运算的话， 按照下面的方式处理应该就可以了。
笔者现在不建议这样做，因为字节码在进行跳转的时候应该比这种方式简单太多了。
 先运算if.condition 部分的代码， 然后把结果保存 在if块的地方判断结果， 并把if.condition的结果设置成自己的结果  如果if.condition部分是true 则执行if.block。 否则什么都不做   在if_else部分 判断if节点的值， 如果为false，则执行else部分  字节码部分 使用字节码尝试实现的话，核心部分应该在于跳转，所以加上适当的跳转字节码即可。
就像我们前面说过的， 字节码是一条一条指令进行执行的， 所以我们再适当的地方插入适当的跳转指令即可。
我们先来看几个自定义指令。 基于栈的指令。
 cjmp 有条件的跳转指令 全写应该是：condition jump  此指令存在一个参数， 表示要跳到的指令序号。 由于序号在本文中难以确定， 且可能会变化， 所以使用标签来代指。 这个指令首先获取栈顶元素， 并将该元素出栈 之后判断栈顶元素的值， 如果值是false的话， 就跳转， 否则此指令无任何效果   jmp 无条件的跳转指令  此指令存在一个参数， 表示要跳到的指令序号。 由于序号在本文中难以确定， 且可能会变化， 所以使用标签来代指。 直接跳转到指定的行数   seti 设置一个变量的值为一个整形数字  seti [varName] [intValue]   dec 声明一个变量 abci i 结尾的表示有一个参数是直接的int值。 很可能是第二个参数。 label: 使用冒号结尾的当做一个标签， 去掉冒号的部分即为标签的名字。 在真正的字节码里面应该是不直接使用变量名的， 而是会把变量名转换成数组的索引。 笔者目前只用于示意说明，所以这样写了。  下面看一段模拟指令。 （伪代码）</description>
    </item>
    
    <item>
      <title>Cpp 踩坑记录</title>
      <link>https://fantasyplayer.link/program/cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Sat, 01 May 2021 15:25:44 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/cpp-%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</guid>
      <description>#param once 的缺点： 相同文件内容的不同位置会视为两个文件 当出现这个状况的时候， 可能会引发重定义的错误。
更多解释可见： https://stackoverflow.com/a/1946730/11226492
一个可能的场景是这样的： 有一个项目A， 有一个项目B， 项目B依赖项目的A的头文件，且两个项目都由同一个人开发。
现在项目B是在项目A内部的， 且项目B使用的是相对路径引用的项目A的头文件。
大致的文件夹结构如下所示。
A + source + include + modProject + + B + + + include + + + source + README.md 目前的情况是： 在B的源代码里面使用诸如 ../../include/abc.h 的形式引用A的头文件。
开发这些项目的开发者发觉这样写不太美观，而且不方便拓展。所以决定将项目A的头文件安装到/usr/local/include/A 目录下 。
这时，就需要把项目B里面的所有引用位置都纠正了，否则就可能出现重定义的情况。 （这里只讨论使用 #param once 的情况，使用宏定义的方式应该不会出现这样的情况。 ）</description>
    </item>
    
    <item>
      <title>自制脚本语言[4.2] 复合数值运算</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%804.2-%E5%A4%8D%E5%90%88%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sun, 21 Mar 2021 11:24:13 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%804.2-%E5%A4%8D%E5%90%88%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/</guid>
      <description>本篇来描述一下类似 a + b + c 得运算内容。
同样，本篇只是说明一个可用于实现得概念模型， 并没有提供什么优化技巧。
详细内容 上一节我们讨论了两元运算， 现在我们讨论一下存在更多元素得运算表达式。
下面来看一段代码。
a = 1; b = 2; c = 3; d = a + b + c; e = a - b - c; f = a * b + c; g = a + b * c; h = a + b + c + a + c; i = a + b * c + a ; 基本逻辑 上面得例子在运算得时候至少存在3个元素，这在实现上并不需要修改上节所实现得逻辑，而是需要在生成抽象语法树(AST)得地方下功夫。</description>
    </item>
    
    <item>
      <title>自制脚本语言[4.1] 数值运算</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%804.1-%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/</link>
      <pubDate>Sun, 07 Mar 2021 10:07:09 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%804.1-%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/</guid>
      <description>本篇来描述一下数值运算相关的内容。
本篇描述的只是最简单的实现方式， 并没有提供什么优化技巧。
详细内容 数值运算应该编程里必不可少的一部分， 所以一个脚本语言引擎应该需要实现数值运算的功能。
下面来看一段代码。
a = 1; b = 2; c = a + b; d = a - b; e = a / d; f = a * b; g = a % d; h = a ^ b; i = a | b; j = a &amp;amp; b; k = ~ a ; 大概需要实现的运算类型就是 加减乘除，取模以及位运算。 读者可以根据自己的需求只实现部分的运算符号， 或者实现更多的符号。 （自定义新的符号）
基本逻辑 这里只讨论单个运算符， 不讨论多个运算符的情况。 比如 d = a + b + c 这种暂时不讨论。</description>
    </item>
    
    <item>
      <title>自制脚本语言[3.2]抽象语法树的简单介绍</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%803.2-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 07 Feb 2021 16:00:56 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%803.2-%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid>
      <description>基本内容 在进行了正确的语法分析之后，会生成抽象语法树。
一般情况下是一段代码生成一个抽象语法树。 （常见的情况是一个文件或者一块代码。）
本篇来简单的描述一下抽象语法树的内容， 由于笔者的知识储备并不是特别的深，所以可能还需要读者阅读更多的资料。
抽象语法树就是一个树，树是一种基本的数据结构， 主要是由节点构成。
下面定义来自维基百科。
 每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路(cycle)  词法分析会从字符流中生成出词法单元， 然后由语法分析进行组装，产生一个AST（抽象语法树）。 基本上来说，树上的每一个节点都是一个词法单元。
下面来看一些示例图。(点击图片可以查看大图)
数值运算
if语句
实际上的树要比笔者给的图更加复杂， 因为在设计的时候， 会考虑如何复用， 所以会进行抽象。 再进行了一定的抽象之后， 会多出一些层次， 但是那些多出来的内容在理解AST的时候是不太重要的。
只要能够组织基本的AST， 那么复杂的其实也不难。 基本上来说， 复杂的AST只是一个量变和正常量变带来的些许复杂度。
代码示例 下面给出一些langX的代码示例， 辅助读者理解这部分内容。
struct Node { NodeType type; // 在执行结束之后是否进行 free 操作  bool freeOnExecuted; // 当前节点的值 . 如果当前结点是一个常量数字， 则free 的时候会施放这个值得内存  Object *value; // 万能指针 ， 主要用于放置参数什么的  void *ptr_u; // 节点状态  NodeState state; // 当前节点所在的文件信息  NodeFileInfo fileinfo; // 后置值 ， 如果当前节点为一个 变量节点， 当前属性则为有用  Object *postposition; Variable *var_obj; Constant *con_obj; Operator *opr_obj; ArrayInfo *arr_obj; }; // 节点的文件信息 struct NodeFileInfo { // 文件名  // const char * filename;  // 修改成 std::string 试试，上面的那个类型要处理一下  std::string filename; // 行号  int lineno; }; struct Constant { int iValue; double dValue; char* sValue; char cValue; // 当前常量是否是一个 bool 类型得元素  bool flagBool = false; }; // 数组声明时使用 struct XArrayNode { // 数组名字  char * name; // 数组长度  int length; // 变量长度索引 .</description>
    </item>
    
    <item>
      <title>自制脚本语言[3.1] 环境与节点运算的值</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%803.1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E8%8A%82%E7%82%B9%E8%BF%90%E7%AE%97%E7%9A%84%E5%80%BC/</link>
      <pubDate>Sun, 07 Feb 2021 15:00:56 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%803.1-%E7%8E%AF%E5%A2%83%E4%B8%8E%E8%8A%82%E7%82%B9%E8%BF%90%E7%AE%97%E7%9A%84%E5%80%BC/</guid>
      <description>本篇来描述一下 ”环境“相关的内容。
这部分内容是笔者从《两周自制脚本语言》这本书上学来的。
简单来说 环境就是一个K-V形式的Map。
 Key 是变量名 Value 是 变量值 一个环境表示一个作用域。 比如函数内部，类内部，脚本内部等。  这里需要提一下， 如果读者使用Java语言来实现脚本语言引擎，或者读者只是想学习一下，或者读者只是追求一个简单的脚本语言引擎，那么建议使用这种方式， 否则，不建议使用这种方式。
如果读者想实现一个复杂的， 稳定的脚本语言引擎， 那么建议使用变量表的形式来实现环境。
一个例子是使用数组或者链表来存放变量的值，对变量的引用在编译期间转换成具体的索引，而非变量名。
由于笔者还没有实现过相关的方式，所以本篇不讨论相关内容。也许后面笔者实现过了之后 会写一篇博文进行相关介绍 😂😂😂
详细说明 我们先来讨论一下 最简单的赋值行为。
先看一下下面的代码。
// 本段代码的内容都是在一个脚本文件内部的。 a = 1; b = &amp;#34;hello&amp;#34;; c = new Test(); d = a + 1; 为了使变量这个功能得以实现， 我们需要保存变量的当前值， 以使未来在使用这个变量的时候可以获取到正确的值。
所以我们可以使用下面的方式进行实现。
 新建一个新的 Map ，用于表示脚本的环境。 碰到 a = 1; 这条语句的时候， 把a的值 设置成 1 碰到 b = &amp;quot;hello&amp;quot;; 这条语句的时候， 把b的值设置成hello 碰到 c = new Test(); 的时候， 实例化 Test类，生成一个对象，并将对象的引用赋值给c 碰到 d = a + 1;  这条语句的时候， 首先取出a的值， 然后进行加法运算， 之后将结果赋值给 d  附注：</description>
    </item>
    
    <item>
      <title>自制脚本语言[2] 类型相关内容的介绍</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%802-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Sun, 07 Feb 2021 14:59:56 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%802-%E7%B1%BB%E5%9E%8B%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9%E7%9A%84%E4%BB%8B%E7%BB%8D/</guid>
      <description>本篇来描述一下 类型相关的内容。
脚本语言引擎需要提供一些基本类型和至少一个复杂类型的抽象(类，表等)。
基本类型 就拿JAVA语言的基本类型来举例： boolean,byte,char,short,int,long,float,double
其中的每一个类型都是基本元素，基本上在使用的时候不会拆分成更小的类型。
除了上述的关于数值的类型之外， 常用的还有一个字符串类型。 （在Java中 字符串不算基本类型。算引用类型。但在读者自己开发的脚本语言中，则可以自己定义。）
笔者在langX中定义的基本类型有下面几个：
 数值类型 （整数， 浮点数， 布尔） null 类型 字符串类型 数组 函数  别的复杂类型基本上都需要使用上述的类型进行组成。
复杂类型的抽象 基本上可以理解为JAVA里的类， lua里的表。
下面请看一个JAVA的代码片段。
@Data public class Student { // 唯一编号  private int id; // 姓名  private String name; // 年龄  private int age; // 是否毕业了  private boolean graduation; public boolean isGraduation(){ return graduation; } } 上面描述一个叫 Student的类， 即一个复杂类型。这个类由字段，方法，注解组成，其中大部分字段使用的基本类型， 还有部分字段使用的是复杂类型（字符串）。
这个类是一个具体的复杂类型， 为了使脚本语言引擎可以支持这个复杂类型， 我们需要实现一套机制。 这套机制可以表述一个复杂类型。</description>
    </item>
    
    <item>
      <title>自制脚本语言[1] 词法分析与语法分析</title>
      <link>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%801-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 18 Jan 2021 20:18:27 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%801-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</guid>
      <description>本篇来描述如何做语法分析和词法分析。
有两种方式可以做词法分析和语法分析， 一是自己纯手写， 二是使用第三方工具。
 手写的优势  灵活性比较高 可以提供较好的错误提示给脚本语言的用户   手写的劣势  在没有基础的情况下，可能会需要更多的时间来完成这件事 可能会出现一些BUG   使用第三方工具的优势  较为出名的第三方工具往往都比较稳定 只需要关心语法结构， 而不用特别关心如何实现。   使用第三方工具的劣势  不够灵活，如果某些特性第三方工具没有的话，很可能就实现不了了。 提供给脚本语言用户的错误提示可能不够精确。    一般来说，使用哪种方式看读者的喜好。 笔者下面介绍一下部分已知的工具是使用哪种方式实现的。
 《两周自制脚本语言》 提供的是手写方式。 lua 是使用的手写方式。 早期的mysql 应该是使用的第三方工具。 （因为它给的提示特别烂。。）  第三方工具 因为使用第三方工具比较简单， 所以笔者采用第三方工具的方式来实现langX的词法解析与语法解析。
下面介绍一下笔者知道的几种工具。
 词法分析器： flex(lex) doc 。 语法分析器： yacc(bison) doc 。 语法分析+词法分析： tree-sitter doc 。  笔者这里统一使用 lex 称呼 flex/lex , 使用yacc 称呼 yacc/bison， lex+yacc是一起配合使用的。
Tree-sitter 则是一个单独使用的工具， 下面笔者就来更详细的介绍一下这几个工具。</description>
    </item>
    
    <item>
      <title>自制脚本语言 - 开篇</title>
      <link>https://fantasyplayer.link/program/%E5%A6%82%E4%BD%95%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E5%BC%80%E7%AF%87/</link>
      <pubDate>Mon, 11 Jan 2021 21:13:45 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%A6%82%E4%BD%95%E8%87%AA%E5%88%B6%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80-%E5%BC%80%E7%AF%87/</guid>
      <description>这个小系列将会介绍如何自制一门脚本语言。
主要内容 优劣 自制脚本语言将会有下面的好处：
 自己可以对脚本语言的语法，特性进行定制化 可以大概了解别的编程语言是如何运作的。 增强逻辑思维能力。  自制脚本语言将会有下面的坏处：
 需要大量的时间进行学习，调试。 做出来的东西往往只是一个玩具。 想要实现一个成熟的脚本语言 很难。 编写脚本的库也需要很多时间。  langX 笔者曾经使用cpp尝试写了一门脚本语言， 目前已经开源。
地址是： https://github.com/Aincvy/langX
本系列将会引用该工程里面的代码和设计思想。不过，有一点需要注意的是，该项目目前还十分的不成熟。
推荐阅读书籍以及其他 两周自制脚本语言
笔者就是看这本书入门的， 但是这本书存在一个很大的方向性问题， 即： 本书并没有使用字节码和VM的方式来实现执行。
不过，还是值得一看的入门书籍。
本书是使用Java作为实现语言的。
深入理解Java虚拟机（第3版）
如果读者是一名JAVA程序员， 那么可以看看这本书， 了解一下jvm的内容。 无论是对于JAVA，还是对于自制脚本语言都有很大的帮助。
https://github.com/lua/lua
这是lua源代码， 也有阅读的价值。
脚本语言的结构介绍 一般情况下， 脚本语言可以划分为几个部分。
 词法分析与语法分析 类型对象 （数值，字符串，对象，等） ⭐ 栈 或者 环境 ⭐ 虚拟机 或者 直接执行节点 ⭐ GC部分  其中， 词法分析与语法分析存在一些第三方工具可以使用， 笔者将会在下一篇博文中介绍。
虚拟机 与直接执行节点 语法分析之后会生成一个抽象语法树（Abstract Syntax Tree，AST） ， 树里面存在很多个节点。
直接执行节点在初期的时候比较方便， 但是当逻辑越来越复杂，语言特性越来越多的时候，似乎就不是很好用了。 在跳转语句上， 直接执行节点没有虚拟机方便，简单。</description>
    </item>
    
    <item>
      <title>Cpp程序在调试模式下正常，在常规模式就崩溃得情况</title>
      <link>https://fantasyplayer.link/program/cpp%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%AD%A3%E5%B8%B8%E5%9C%A8%E5%B8%B8%E8%A7%84%E6%A8%A1%E5%BC%8F%E5%B0%B1%E5%B4%A9%E6%BA%83%E5%BE%97%E6%83%85%E5%86%B5/</link>
      <pubDate>Mon, 14 Dec 2020 21:22:30 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/cpp%E7%A8%8B%E5%BA%8F%E5%9C%A8%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%AD%A3%E5%B8%B8%E5%9C%A8%E5%B8%B8%E8%A7%84%E6%A8%A1%E5%BC%8F%E5%B0%B1%E5%B4%A9%E6%BA%83%E5%BE%97%E6%83%85%E5%86%B5/</guid>
      <description>笔者前几天在使用cpp(c++)写代码得时候， 发现一个很蛋疼得问题， 在使用lldb进行调试得时候，程序完全正常，没有错误。 而退出调试模式， 使用命令行运行程序得时候， 则会触发内存错误。
经过一番查找之后发现， 笔者发现有些类得属性没有进行初始化。 。。
这可能是一个非常基础得错误。。 但是笔者一般写Java得时候 是不需要考虑这个问题得。。😂😂 😂
大致情况是这样得。
// 物品类， 占位使用 class Thing { } class Person { public: void take(Thing* thing){ if( m_onHand == nullptr ){ // do something ..  } // do something ..  } private: // 手里正在拿得东西  Thing* m_onHand; } 在调试模式下， 上述代码得属性部分 m_onHand 是一个nullptr，这会产生预期的行为。
而非调试模式下，似乎就不是一个nullptr ， 则会产生不可预期得内存错误。 😢😢😢
笔者使用得解决办法就是在声明得时候这么写： Thing* m_onHand = nullptr;
除此之外， 笔者还搜索到了一种可能性。
链接在此： https://stackoverflow.com/questions/186237/program-only-crashes-as-release-build-how-to-debug/186285#186285
下面是原文引用：</description>
    </item>
    
    <item>
      <title>代码规范建议</title>
      <link>https://fantasyplayer.link/program/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 07 Dec 2020 18:48:17 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%BB%BA%E8%AE%AE/</guid>
      <description>笔者在公司里面写的内容，本文经过部分删减。
命名规范 # 1. 属性/成员 命名   静态常量属性 即使用 static final 修饰的属性， 属性名全部大写并添加javadoc的注释。 比如下面的例子
  /** * 消息的线程数量 */ public static final int MSG_THREAD_NUM = 8; /** * redis 连接池的 线程数量 */ public static final int REDIS_CONNECTION_POOL_SIZE = 4;     私有的实例属性 采用 驼峰命名法。 并需要使用单行注释 简单说明下含义、
 经常出现的变量名可以不写注释。 Map Or MapSubMap 需要写明 key 和 value的含义。 如果是关键字开头的命名，比如 do ,for 可用_ 下划线开头， 比如_forConsole, _doWorkTime 尽量不要使用这种关键字开头的命名 😄。    方法名采用 驼峰命名法， 并需要添加 javadoc 注释， 在必要的时候 也需要写明参数的含义。</description>
    </item>
    
    <item>
      <title>关于单元测试的一点小想法</title>
      <link>https://fantasyplayer.link/program/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%83%B3%E6%B3%95/</link>
      <pubDate>Mon, 05 Oct 2020 20:22:34 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E6%83%B3%E6%B3%95/</guid>
      <description>编程语言： Java
因为笔者并没有完成过单元测试， 所以本篇内容比较少，也是一些小想法。
笔者在项目开发到了一定阶段的时候，考虑加入单元测试辅助开发。 但是呢，在搜索文档和简单测试的时候发现， 笔者现在的项目结构似乎无法进行单元测试， 所以就没再继续下去。
一些建议 单元测试一定要从项目开始的时候就进行规划， 否则开发中可能会很难再添加单元测试。
笔者搜索到的是一个叫做mockito 的工具， 这个工具不需要建立很长的依赖内容， 它可以让你断言某个方法的执行次数。
但是，这个工具对单例模式似乎不太友好。
什么意思呢， 就是说当你的代码中使用大量的单例模式的时候，这个框架可能就不太好用了。 原因是mockito基本上可以mock一个类，接口或者一个实例对象。 当类A依赖类B的时候，你在 mock 类 A 的时候，似乎会自动创建一个类 B。当然，你可以手动 mock 一下类 B，然后赋值给类 A 的属性。
在使用单例模式的时候， 代码中会存在大量类似ConfigManager.getInstance().getShopData(shopGoodsId)的代码，这里是直接使用 ConfigManager 类的单例的， 在执行测试方法的时候可能会出现异常。 如果想把 ConfigManager做成 mock 之后的类，则可能需要做一个接口替换 ConfigManager 的 Instance属性, 而这无疑会破坏单例模式。
其他内容 当你无法使用这类单元测试的框架之后， 你可以试着考虑做一个自动化测试的工具。
如果你使用Jenkins之类的工具 做持续集成， 那么就可以在打包发布之后 执行下自动化测试，并可以考虑生成一个 html 页面的报告。
本文如果有什么错误的地方， 欢迎指正。 😄😄😄</description>
    </item>
    
    <item>
      <title>公司面试使用的面试题</title>
      <link>https://fantasyplayer.link/program/%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 28 Sep 2020 22:34:08 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>简述 前些天，公司缺了一个做web后台的人，因为公司做后端的人就剩我一个了，所以面试的任务就交给我了。
笔者个人来说， 是第一次面试别人， 且笔者对 web 技术并不熟悉。 因为笔者是做游戏开发的，对 web 开发并不是很感兴趣，所以了解的不多。
仔细考虑了一下之后，笔者决定出两道很基本面试题来过滤一下面试者，笔者认为如果能完成这两道题，则说明基本逻辑的编写应该没有问题，那样就可以干活了。
面试题内容 一、 有下面代码
// file: Student.java // 学生信息类 @Data public class Student { // 学号  private int no; // 姓名  private String name; // 年龄  private int age; // 年级 1-16  private int grade; } // file: StudentFilter.java // 学生信息筛选的方法 public class StudentFilter{ public static void test(){ var list = new ArrayList&amp;lt;Student&amp;gt;(); list.add(new Student(1,&amp;#34;学生1&amp;#34;, 7, 2)); // 此处省略添加 学生信息 N 个  // 问题： 请输出8~10岁（都包含） 在上三年级的学生数量，以及信息  // PS： 将grade = 3 视作三年级即可  // 在下面空白处作答 即可。  } } 二、 SQL语句问题</description>
    </item>
    
    <item>
      <title>Java字节操作的简单描述</title>
      <link>https://fantasyplayer.link/program/java%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Mon, 21 Sep 2020 20:33:04 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0/</guid>
      <description>byte[]和 int 互相转换 // 将 byte[] 转换成 int byte[] input = {(byte)0x65, (byte)0xFF, (byte)0x31 }; // 使用大端的方式转换成 int ： x == 0x65FF31 int x = (input[0] &amp;amp; 0xFF) &amp;lt;&amp;lt; 16 | (input[1] &amp;amp; 0xFF) &amp;lt;&amp;lt; 8 | (input[2] &amp;amp; 0xFF) &amp;lt;&amp;lt; 0; // 使用小端的方式转换成 int : y == 0x31FF65 int y = (input[0] &amp;amp; 0xFF) &amp;lt;&amp;lt; 0 | (input[1] &amp;amp; 0xFF) &amp;lt;&amp;lt; 8 | (input[2] &amp;amp; 0xFF) &amp;lt;&amp;lt; 16; 介绍一些概念  一个 int 由4个字节组成，分别记作 x0,x1,x2,x3 一个字节由8个位(bit) 组成， 每个 bit的值只能为1或者0 一个 int 由 32个位(bit) 组成。 | 是按位或的操作符， 当第一项的第n位或者第二项的第n位的值为1 ，结果的第 n 位就是1 &amp;amp; 是按位与的操作符， 当两项中的第 n 位的值都是1， 则结果的第 n 位的值就是1  解释 在大端模式下， 组成 int 的字节数量不够的时候， 省略左边的值（我猜的😂）。</description>
    </item>
    
    <item>
      <title>Mysql 时区的问题</title>
      <link>https://fantasyplayer.link/program/mysql-%E6%97%B6%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 07 Sep 2020 21:33:07 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/mysql-%E6%97%B6%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>在链接字符串尾部添加参数 serverTimezone=Asia/Shanghai 即可让 mysql 的链接使用上海的时区。
其他说明 我刚开始尝试的是 serverTimezone=GMT+8 但是不知道为啥，没有生效。 目前考虑可能是 +的问题, 使用GMT%2b8 可能有效（笔者没有尝试）。 这是 URLEncode 之后的代码。
如果在服务器上使用 yum/apt 等包管理器进行安装， mysql应该会使用系统的时区， 这个时候得客户端一般是不需要指定时区的。
我们这次是使用 docker 安装的， 默认可能是 GMT+0 的时区。</description>
    </item>
    
    <item>
      <title>Java8LocalDateTime以及相关内容</title>
      <link>https://fantasyplayer.link/program/java8localdatetime%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</link>
      <pubDate>Mon, 11 May 2020 21:50:38 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java8localdatetime%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</guid>
      <description>Java8LocalDateTime以及相关内容 在Java8中，jdk包含了新的 时间API:LocalTime,LocalDate,LocalDateTime
先看一段代码吧
// LocalTime, only time LocalTime localTime = LocalTime.now(); LocalTime localTime1 = LocalTime.of(10,30,50); // 参数列表: hour,minute,second  LocalTime nTime = localTime.plusHours(1); LocalTime hour = localTime.get(ChronoField.HOUR_OF_DAY); localTime.getHour(); localTime.getMinute(); // LocalDate, only date LocalDate localDate = LocalDate.now(); LocalDate localDate1 = LocalDate.of(2020,10,15); // 参数列表: year, month, dayOfMonth  LocalDate year = localDate.getYear(); var year1 = localDate.get(ChronoField.YEAR); var date = localDate.getDayOfYear(); LocalDate nDate = localDate.plusYears(1).plusDays(15); // LocalDateTime, date and time LocalDateTime localDateTime = LocalDateTime.</description>
    </item>
    
    <item>
      <title>java字符串格式化</title>
      <link>https://fantasyplayer.link/program/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Mon, 11 May 2020 21:50:38 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>简介 本文主要会介绍下面几种格式化的方式。
 String.format() System.out.printf() 严格来说， 这并不是一种字符串格式化的方法。 MessageFormatter.format()  String.format() 这是一个 较为常用的 格式化方法， 类似 C语言的 sprintf() 函数。
先给出几个示例 。
// in jdk10+ ，低于jdk10的时候， var 换成 String 即可 int a = 1, b = 2 ; var str1 = String.format(&amp;#34;%d + %d = %d&amp;#34;, a , b , (a + b) ); // 1 + 2 = 3  float f = 1.5678f; var str2 = String.format(&amp;#34;f = %f&amp;#34;, f); // f = 1.</description>
    </item>
    
    <item>
      <title>利用做饭的流程来解释多线程的应用</title>
      <link>https://fantasyplayer.link/program/%E5%88%A9%E7%94%A8%E5%81%9A%E9%A5%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%9D%A5%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 11 May 2020 21:50:00 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%88%A9%E7%94%A8%E5%81%9A%E9%A5%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%9D%A5%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>单线程 &amp;amp; 单人做饭 单人做饭的流程 （我的流程）  选择吃什么 买菜，买肉 做米饭 洗肉（解冻肉），洗菜，择菜。 切肉 切菜， 切辣椒，葱花，姜片。 炸肉，下花椒八角， 老抽，醋 把肉盛出来 （或者不盛） 下葱姜， 炒香后下辣椒 下蔬菜 放调味料 关火， 盛出来 盛米饭，吃饭  单线程 这里假定任务是处理一个玩家购买金币的 socket 请求
 获取网络数据 解析成我们需要的数据格式 从数据库/缓存取出玩家信息 对玩家数据进行上锁 获取配置表数据 （花多少钻石可以购买多少金币） 检测玩家的钻石是否足够 修改钻石和金币的数量 保存玩家的数据到数据库/缓存， 并解锁玩家数据 产生响应结果 发送数据给客户端  多线程 &amp;amp; 餐馆做饭 餐馆做饭 根据职责进行人员的分配，配合整个做菜流程
按职责分成下面几个角色。
 采购员 案板 打杂 厨师 服务员 客人  每个角色的职责大致如下。
 采购员 （买菜，买肉） 案板 （切菜， 切肉） 打杂 （做米饭，配菜，送菜给服务员，拿盘子等） 厨师 （炒菜） 服务员 （把菜从厨房间端到客人面前，给客人盛米饭） 客人 （吃饭）  需要的人员大大增加了， 每个人员负责的任务大大减少了。</description>
    </item>
    
    <item>
      <title>Akka Grpc的简单入门</title>
      <link>https://fantasyplayer.link/program/akka-grpc%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 11 May 2020 21:49:36 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/akka-grpc%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</guid>
      <description>Akka Grpc 的简单入门 简介 Akka Grpc 是一个 rpc 框架。 基于akka-http,google protobuf 构建而成。
一些快速的链接。
 官方文档： https://doc.akka.io/docs/akka-grpc/current/index.html Github地址： https://github.com/akka/akka-grpc  详细内容 本篇是一个中文的使用流程把。 使用Java 语言编写代码。
scala 语言和其他类型的编译工具的代码可以在官方文档中找到。
协议文件 option java_multiple_files = true;option java_package = &amp;#34;example.myapp.helloworld.grpc&amp;#34;;option java_outer_classname = &amp;#34;HelloWorldProto&amp;#34;;package helloworld;// The request message containing the user&amp;#39;s name. message HelloRequest { string name = 1;}// The response message containing the greetings message HelloReply { string message = 1;}////////////////////////////////////// The greeting service definition. service GreeterService { //////////////////////  // Sends a greeting //  ////////*****/////////  // HELLO //  ////////*****/////////  rpc SayHello (HelloRequest) returns (HelloReply) {} // Comment spanning  // on several lines  rpc ItKeepsTalking (stream HelloRequest) returns (HelloReply) {} /* * C style comments */ rpc ItKeepsReplying (HelloRequest) returns (stream HelloReply) {} /* C style comments * on several lines * with non-empty heading/trailing line */ rpc StreamHellos (stream HelloRequest) returns (stream HelloReply) {} }简单的说明</description>
    </item>
    
    <item>
      <title>Java私有类型装箱拆箱</title>
      <link>https://fantasyplayer.link/program/java%E7%A7%81%E6%9C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</link>
      <pubDate>Thu, 30 Apr 2020 21:27:47 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java%E7%A7%81%E6%9C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</guid>
      <description>简述 在尽可能的情况下， 都应该使用 java的私有类型， 而装箱类型应该少用。
因为 装箱的类型 会占用更多的内存。
内存占用相关的内容    私有类型 装箱类型 内存占用(私有类型/ 装箱类型)     boolean Boolean 1 byte / 16 bytes   byte Byte 1 byte / 16 bytes   short Short 2 bytes / 16 bytes   char Char 2 bytes / 16 bytes   int Integer 4 bytes / 16 bytes   long Long 8 bytes / 16 bytes   float Float 4 bytes / 16 bytes   double Double 8 bytes / 16 bytes     1 byte 是一个字节</description>
    </item>
    
    <item>
      <title>[状态机变种]有关状态栈的一些记录</title>
      <link>https://fantasyplayer.link/program/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%98%E7%A7%8D%E6%9C%89%E5%85%B3%E7%8A%B6%E6%80%81%E6%A0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Tue, 27 Dec 2016 21:11:56 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%98%E7%A7%8D%E6%9C%89%E5%85%B3%E7%8A%B6%E6%80%81%E6%A0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</guid>
      <description>写这篇文章的时候，笔者还是一个很菜的菜鸟， 本文可能有误。
我在弄我们公司的项目的时候。 地图 上面的每一个实体，我是当作一个单位来看的。每隔若干毫秒对地图所有的实体进行一个update ，更新他们的状态。
在更新他们的状态的时候，往往需要根据他们的当前状态来决定怎么更新他们。这可以用状态机来实现。 也可以考虑用行为树来实现。但是我不会。。 所以我采用了一种简单版本的状态机来做。
所有的状态如下列表
 等待 眩晕 移动 站立 追击 使用技能 被嘲讽  我本来是记录一个实体就一个状态。根据不同的状态做事情。但是有个问题是，如果这个实体进行等待中了， 在他等待结束的时候就需要调整他的状态。 我本来是根据一些别的参数（当前是否有移动路径，当前是否有追击对象） 来做调整的。 但是这样做容易出bug.. 而且很不好。
所以我做了一些调整。 我现在让每个单位身上不是具有一个状态。而是具有一个状态栈。 这样就能比较良好的处理各个状态之间的转换。尤其是处理等待，眩晕的时候。
默认的栈顶是一个 站立 状态。 当有新的状态进来的时候 直接入栈。 当该状态结束的时候 则把该状态出栈。
比如 站立的时候 因为某种需求变成移动状态了。 然后就一直移动，直到 到达目的地。然后 退回成站立状态。 比如在移动追击某个敌人的时候 转换成了施放技能的状态。 等技能释放 结束之后 还是在 追击状态。
个人觉得，这种情况实现起来比行为树简单一些。 然后出问题的情况比 单一状态的那种 要小一些。</description>
    </item>
    
    <item>
      <title>So 动态库引用问题</title>
      <link>https://fantasyplayer.link/program/so-%E5%8A%A8%E6%80%81%E5%BA%93%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 06 Dec 2016 21:20:43 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/so-%E5%8A%A8%E6%80%81%E5%BA%93%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <description>如果一个动态库 a.so 依赖了另外一个动态库 b.so .
那么， 当 b.so 的内容变更的时候， 可能就需要重新编译 a.so ，否则的话会产生一些无法预知，而且莫名奇妙的问题。 比如 明明代码写的是调用 b.so 内的函数 add ，在执行的时候却调用了 sub函数。 当碰到这种情况的时候， 重新编译一下a.so 库就好了。</description>
    </item>
    
    <item>
      <title>Java 计算 抛物线的近似长度 炮弹的近似飞行时间</title>
      <link>https://fantasyplayer.link/program/java-%E8%AE%A1%E7%AE%97-%E6%8A%9B%E7%89%A9%E7%BA%BF%E7%9A%84%E8%BF%91%E4%BC%BC%E9%95%BF%E5%BA%A6-%E7%82%AE%E5%BC%B9%E7%9A%84%E8%BF%91%E4%BC%BC%E9%A3%9E%E8%A1%8C%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sun, 20 Nov 2016 21:22:43 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java-%E8%AE%A1%E7%AE%97-%E6%8A%9B%E7%89%A9%E7%BA%BF%E7%9A%84%E8%BF%91%E4%BC%BC%E9%95%BF%E5%BA%A6-%E7%82%AE%E5%BC%B9%E7%9A%84%E8%BF%91%E4%BC%BC%E9%A3%9E%E8%A1%8C%E6%97%B6%E9%97%B4/</guid>
      <description>记录一下 我是怎么计算抛物线的近似长度 。。 想当初我找了抛物线长度的计算公式， 找了好久都没找到简单方便的。。。
首先普及一下相关公式 ：
抛物线的一般方程: y=ax²+bx+c ，抛物线的顶点式： y=a(x-h)²+k (a≠0，k为常数） 根本炮弹的出发点和目标位置， 以及策划的配置表， 我可以获得到 抛物线线段的起始点， 和终点， 以及抛物线的顶点 （1/2距离，策划配置） 利用抛物线的顶点式可以计算出抛物线的方程式。 计算出方程式之后， 就可以根据 相应的x 计算出y的坐标。
然后把起始点和终点之间的距离分段。 比如x的步长是0.15， 那么计算出 (0,0) 到 (0.15,y[根据方程式计算出值]) 的三角形斜边距离。 继续推进 x, 计算出 (0.15,y1) 到 (0.30,y2) 的距离。 一直从起始点(0,0) 到 终点(x,0) 这样就可以求出 这个抛物线线段的近似距离。 然后 炮弹的飞行时间， 就是距离除以速度就Ok 了。
大致就是下图这样的。</description>
    </item>
    
    <item>
      <title>Netty和cocos2dx一起使用碰到的问题</title>
      <link>https://fantasyplayer.link/program/netty%E5%92%8Ccocos2dx%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 17 Apr 2016 21:36:18 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/netty%E5%92%8Ccocos2dx%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8%E7%A2%B0%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>简述一下环境：　java netty 的服务端， cocos2dx 的客户端
昨天测试的时候 发生了一个奇怪的现象。 服务端在本地跑的时候， 都是正常的。 放到阿里云的服务器上面去的时候。 在客户端与服务端进行第一次连接的时候一切OK，然后第二次连接的时候 就出现了问题。。。 问题具体发生的原因我现在也还没弄明白。。。
然后，我就查阅了一下 有关 windows select IO 异步模型的资料。 虽然这病没有帮助我解决问题， 但总归是有了些启发。
然后我想，我加一下发送的数据包的长度进去吧。 于是乎，我在 netty 上面加了一个 解码器， 标注了发来的数据包会标准它的长度。 然后客户端在发送的时候会先发一个 表示长度的数据。 一般是采用 4个字节长度的大小。
因为大小端的问题， 在弄长度的时候 也发生了乱七八糟的问题。长度不能正确被解析，因为我也没有什么经验，所以好多元素对于我来说都是未知的。 我也不能确定问题到底在哪， 所以也比较蛋疼。 这种时候， 没办法，只能使用排除法了。 我先写了一个 java 的类 来测试大小端的问题。
我使用 java.nio.bytebuffer 类来生成byte数组。 我先 使用 putInt 方法， 将要发送的字节数量 put 进去， 然后在放入具体的数据。
Socket socket = new Socket(&amp;#34;127.0.0.1&amp;#34;, 7000); ByteBuffer buffer = ByteBuffer.allocate(1024); buffer.putInt(8); buffer.putInt(1); buffer.putInt(2); socket.getOutputStream().write(buffer.array(), 0, 12); socket.</description>
    </item>
    
  </channel>
</rss>