<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programs on Fanstasy Player / 幻想系玩家</title>
    <link>https://fantasyplayer.link/program/</link>
    <description>Recent content in Programs on Fanstasy Player / 幻想系玩家</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 28 Sep 2020 22:34:08 +0800</lastBuildDate>
    
	<atom:link href="https://fantasyplayer.link/program/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>公司面试使用的面试题</title>
      <link>https://fantasyplayer.link/program/%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
      <pubDate>Mon, 28 Sep 2020 22:34:08 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%85%AC%E5%8F%B8%E9%9D%A2%E8%AF%95%E4%BD%BF%E7%94%A8%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
      <description>简述 前些天，公司缺了一个做web后台的人，因为公司做后端的人就剩我一个了，所以面试的任务就交给我了。
笔者个人来说， 是第一次面试别人， 且笔者对 web 技术并不熟悉。 因为笔者是做游戏开发的，对 web 开发并不是很感兴趣，所以了解的不多。
仔细考虑了一下之后，笔者决定出两道很基本面试题来过滤一下面试者，笔者认为如果能完成这两道题，则说明基本逻辑的编写应该没有问题，那样就可以干活了。
面试题内容 一、 有下面代码
// file: Student.java // 学生信息类 @Data public class Student { // 学号  private int no; // 姓名  private String name; // 年龄  private int age; // 年级 1-16  private int grade; } // file: StudentFilter.java // 学生信息筛选的方法 public class StudentFilter{ public static void test(){ var list = new ArrayList&amp;lt;Student&amp;gt;(); list.add(new Student(1,&amp;#34;学生1&amp;#34;, 7, 2)); // 此处省略添加 学生信息 N 个  // 问题： 请输出8~10岁（都包含） 在上三年级的学生数量，以及信息  // PS： 将grade = 3 视作三年级即可  // 在下面空白处作答 即可。  } } 二、 SQL语句问题</description>
    </item>
    
    <item>
      <title>Java字节操作的简单描述</title>
      <link>https://fantasyplayer.link/program/java%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0/</link>
      <pubDate>Mon, 21 Sep 2020 20:33:04 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java%E5%AD%97%E8%8A%82%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0/</guid>
      <description>byte[]和 int 互相转换 // 将 byte[] 转换成 int byte[] input = {(byte)0x65, (byte)0xFF, (byte)0x31 }; // 使用大端的方式转换成 int ： x == 0x65FF31 int x = (input[0] &amp;amp; 0xFF) &amp;lt;&amp;lt; 16 | (input[1] &amp;amp; 0xFF) &amp;lt;&amp;lt; 8 | (input[2] &amp;amp; 0xFF) &amp;lt;&amp;lt; 0; // 使用小端的方式转换成 int : y == 0x31FF65 int y = (input[0] &amp;amp; 0xFF) &amp;lt;&amp;lt; 0 | (input[1] &amp;amp; 0xFF) &amp;lt;&amp;lt; 8 | (input[2] &amp;amp; 0xFF) &amp;lt;&amp;lt; 16; 介绍一些概念  一个 int 由4个字节组成，分别记作 x0,x1,x2,x3 一个字节由8个位(bit) 组成， 每个 bit的值只能为1或者0 一个 int 由 32个位(bit) 组成。 | 是按位或的操作符， 当第一项的第n位或者第二项的第n位的值为1 ，结果的第 n 位就是1 &amp;amp; 是按位与的操作符， 当两项中的第 n 位的值都是1， 则结果的第 n 位的值就是1  解释 在大端模式下， 组成 int 的字节数量不够的时候， 省略左边的值（我猜的😂）。</description>
    </item>
    
    <item>
      <title>Mysql 时区的问题</title>
      <link>https://fantasyplayer.link/program/mysql-%E6%97%B6%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 07 Sep 2020 21:33:07 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/mysql-%E6%97%B6%E5%8C%BA%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>在链接字符串尾部添加参数 serverTimezone=Asia/Shanghai 即可让 mysql 的链接使用上海的时区。
其他说明 我刚开始尝试的是 serverTimezone=GMT+8 但是不知道为啥，没有生效。 目前考虑可能是 +的问题, 使用GMT%2b8 可能有效（笔者没有尝试）。 这是 URLEncode 之后的代码。
如果在服务器上使用 yum/apt 等包管理器进行安装， mysql应该会使用系统的时区， 这个时候得客户端一般是不需要指定时区的。
我们这次是使用 docker 安装的， 默认可能是 GMT+0 的时区。</description>
    </item>
    
    <item>
      <title>Java8LocalDateTime以及相关内容</title>
      <link>https://fantasyplayer.link/program/java8localdatetime%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</link>
      <pubDate>Mon, 11 May 2020 21:50:38 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java8localdatetime%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</guid>
      <description>Java8LocalDateTime以及相关内容 在Java8中，jdk包含了新的 时间API:LocalTime,LocalDate,LocalDateTime
先看一段代码吧
// LocalTime, only time LocalTime localTime = LocalTime.now(); LocalTime localTime1 = LocalTime.of(10,30,50); // 参数列表: hour,minute,second  LocalTime nTime = localTime.plusHours(1); LocalTime hour = localTime.get(ChronoField.HOUR_OF_DAY); localTime.getHour(); localTime.getMinute(); // LocalDate, only date LocalDate localDate = LocalDate.now(); LocalDate localDate1 = LocalDate.of(2020,10,15); // 参数列表: year, month, dayOfMonth  LocalDate year = localDate.getYear(); var year1 = localDate.get(ChronoField.YEAR); var date = localDate.getDayOfYear(); LocalDate nDate = localDate.plusYears(1).plusDays(15); // LocalDateTime, date and time LocalDateTime localDateTime = LocalDateTime.</description>
    </item>
    
    <item>
      <title>java字符串格式化</title>
      <link>https://fantasyplayer.link/program/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Mon, 11 May 2020 21:50:38 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>简介 本文主要会介绍下面几种格式化的方式。
 String.format() System.out.printf() 严格来说， 这并不是一种字符串格式化的方法。 MessageFormatter.format()  String.format() 这是一个 较为常用的 格式化方法， 类似 C语言的 sprintf() 函数。
先给出几个示例 。
// in jdk10+ ，低于jdk10的时候， var 换成 String 即可 int a = 1, b = 2 ; var str1 = String.format(&amp;#34;%d + %d = %d&amp;#34;, a , b , (a + b) ); // 1 + 2 = 3  float f = 1.5678f; var str2 = String.format(&amp;#34;f = %f&amp;#34;, f); // f = 1.</description>
    </item>
    
    <item>
      <title>利用做饭的流程来解释多线程的应用</title>
      <link>https://fantasyplayer.link/program/%E5%88%A9%E7%94%A8%E5%81%9A%E9%A5%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%9D%A5%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 11 May 2020 21:50:00 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%88%A9%E7%94%A8%E5%81%9A%E9%A5%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%9D%A5%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
      <description>单线程 &amp;amp; 单人做饭 单人做饭的流程 （我的流程）  选择吃什么 买菜，买肉 做米饭 洗肉（解冻肉），洗菜，择菜。 切肉 切菜， 切辣椒，葱花，姜片。 炸肉，下花椒八角， 老抽，醋 把肉盛出来 （或者不盛） 下葱姜， 炒香后下辣椒 下蔬菜 放调味料 关火， 盛出来 盛米饭，吃饭  单线程 这里假定任务是处理一个玩家购买金币的 socket 请求
 获取网络数据 解析成我们需要的数据格式 从数据库/缓存取出玩家信息 对玩家数据进行上锁 获取配置表数据 （花多少钻石可以购买多少金币） 检测玩家的钻石是否足够 修改钻石和金币的数量 保存玩家的数据到数据库/缓存， 并解锁玩家数据 产生响应结果 发送数据给客户端  多线程 &amp;amp; 餐馆做饭 餐馆做饭 根据职责进行人员的分配，配合整个做菜流程
按职责分成下面几个角色。
 采购员 案板 打杂 厨师 服务员 客人  每个角色的职责大致如下。
 采购员 （买菜，买肉） 案板 （切菜， 切肉） 打杂 （做米饭，配菜，送菜给服务员，拿盘子等） 厨师 （炒菜） 服务员 （把菜从厨房间端到客人面前，给客人盛米饭） 客人 （吃饭）  需要的人员大大增加了， 每个人员负责的任务大大减少了。</description>
    </item>
    
    <item>
      <title>Akka Grpc的简单入门</title>
      <link>https://fantasyplayer.link/program/akka-grpc%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 11 May 2020 21:49:36 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/akka-grpc%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</guid>
      <description>Akka Grpc 的简单入门 简介 Akka Grpc 是一个 rpc 框架。 基于akka-http,google protobuf 构建而成。
一些快速的链接。
 官方文档： https://doc.akka.io/docs/akka-grpc/current/index.html Github地址： https://github.com/akka/akka-grpc  详细内容 本篇是一个中文的使用流程把。 使用Java 语言编写代码。
scala 语言和其他类型的编译工具的代码可以在官方文档中找到。
协议文件 option java_multiple_files = true;option java_package = &amp;#34;example.myapp.helloworld.grpc&amp;#34;;option java_outer_classname = &amp;#34;HelloWorldProto&amp;#34;;package helloworld;// The request message containing the user&amp;#39;s name. message HelloRequest { string name = 1;}// The response message containing the greetings message HelloReply { string message = 1;}////////////////////////////////////// The greeting service definition. service GreeterService { //////////////////////  // Sends a greeting //  ////////*****/////////  // HELLO //  ////////*****/////////  rpc SayHello (HelloRequest) returns (HelloReply) {} // Comment spanning  // on several lines  rpc ItKeepsTalking (stream HelloRequest) returns (HelloReply) {} /* * C style comments */ rpc ItKeepsReplying (HelloRequest) returns (stream HelloReply) {} /* C style comments * on several lines * with non-empty heading/trailing line */ rpc StreamHellos (stream HelloRequest) returns (stream HelloReply) {} }简单的说明</description>
    </item>
    
    <item>
      <title>Java私有类型装箱拆箱</title>
      <link>https://fantasyplayer.link/program/java%E7%A7%81%E6%9C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</link>
      <pubDate>Thu, 30 Apr 2020 21:27:47 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/java%E7%A7%81%E6%9C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</guid>
      <description>简述 在尽可能的情况下， 都应该使用 java的私有类型， 而装箱类型应该少用。
因为 装箱的类型 会占用更多的内存。
内存占用相关的内容    私有类型 装箱类型 内存占用(私有类型/ 装箱类型)     boolean Boolean 1 byte / 16 bytes   byte Byte 1 byte / 16 bytes   short Short 2 bytes / 16 bytes   char Char 2 bytes / 16 bytes   int Integer 4 bytes / 16 bytes   long Long 8 bytes / 16 bytes   float Float 4 bytes / 16 bytes   double Double 8 bytes / 16 bytes     1 byte 是一个字节</description>
    </item>
    
    <item>
      <title>[占位]关于单元测试的一点想法</title>
      <link>https://fantasyplayer.link/program/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</link>
      <pubDate>Thu, 30 Apr 2020 21:27:01 +0800</pubDate>
      
      <guid>https://fantasyplayer.link/program/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>