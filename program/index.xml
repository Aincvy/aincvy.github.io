<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programs on Fanstasy Player</title>
    <link>http://fantasyplayer.link/program/</link>
    <description>Recent content in Programs on Fanstasy Player</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 11 May 2020 21:50:38 +0800</lastBuildDate>
    
	<atom:link href="http://fantasyplayer.link/program/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java8LocalDateTime以及相关内容</title>
      <link>http://fantasyplayer.link/program/java8localdatetime%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</link>
      <pubDate>Mon, 11 May 2020 21:50:38 +0800</pubDate>
      
      <guid>http://fantasyplayer.link/program/java8localdatetime%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/</guid>
      <description>Java8LocalDateTime以及相关内容 在Java8中，jdk包含了新的 时间API:LocalTime,LocalDate,LocalDateTime
先看一段代码吧
// LocalTime, only time LocalTime localTime = LocalTime.now(); LocalTime localTime1 = LocalTime.of(10,30,50); // 参数列表: hour,minute,second  LocalTime nTime = localTime.plusHours(1); LocalTime hour = localTime.get(ChronoField.HOUR_OF_DAY); localTime.getHour(); localTime.getMinute(); // LocalDate, only date LocalDate localDate = LocalDate.now(); LocalDate localDate1 = LocalDate.of(2020,10,15); // 参数列表: year, month, dayOfMonth  LocalDate year = localDate.getYear(); var year1 = localDate.get(ChronoField.YEAR); var date = localDate.getDayOfYear(); LocalDate nDate = localDate.plusYears(1).plusDays(15); // LocalDateTime, date and time LocalDateTime localDateTime = LocalDateTime.</description>
    </item>
    
    <item>
      <title>java字符串格式化</title>
      <link>http://fantasyplayer.link/program/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Mon, 11 May 2020 21:50:38 +0800</pubDate>
      
      <guid>http://fantasyplayer.link/program/java%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>简介 本文主要会介绍下面几种格式化的方式。
 String.format() System.out.printf() 严格来说， 这并不是一种字符串格式化的方法。 MessageFormatter.format()  String.format() 这是一个 较为常用的 格式化方法， 类似 C语言的 sprintf() 函数。
先给出几个示例 。
// in jdk10+ ，低于jdk10的时候， var 换成 String 即可 int a = 1, b = 2 ; var str1 = String.format(&amp;#34;%d + %d = %d&amp;#34;, a , b , (a + b) ); // 1 + 2 = 3  float f = 1.5678f; var str2 = String.format(&amp;#34;f = %f&amp;#34;, f); // f = 1.</description>
    </item>
    
    <item>
      <title>[占位]利用做饭的流程来解释多线程的原理</title>
      <link>http://fantasyplayer.link/program/%E5%88%A9%E7%94%A8%E5%81%9A%E9%A5%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%9D%A5%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 11 May 2020 21:50:00 +0800</pubDate>
      
      <guid>http://fantasyplayer.link/program/%E5%88%A9%E7%94%A8%E5%81%9A%E9%A5%AD%E7%9A%84%E6%B5%81%E7%A8%8B%E6%9D%A5%E8%A7%A3%E9%87%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8E%9F%E7%90%86/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Akka Grpc的简单入门</title>
      <link>http://fantasyplayer.link/program/akka-grpc%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 11 May 2020 21:49:36 +0800</pubDate>
      
      <guid>http://fantasyplayer.link/program/akka-grpc%E7%9A%84%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8/</guid>
      <description>Akka Grpc 的简单入门 简介 Akka Grpc 是一个 rpc 框架。 基于akka-http,google protobuf 构建而成。
一些快速的链接。
 官方文档： https://doc.akka.io/docs/akka-grpc/current/index.html Github地址： https://github.com/akka/akka-grpc  详细内容 本篇是一个中文的使用流程把。 使用Java 语言编写代码。
scala 语言和其他类型的编译工具的代码可以在官方文档中找到。
协议文件 option java_multiple_files = true;option java_package = &amp;#34;example.myapp.helloworld.grpc&amp;#34;;option java_outer_classname = &amp;#34;HelloWorldProto&amp;#34;;package helloworld;// The request message containing the user&amp;#39;s name. message HelloRequest { string name = 1;}// The response message containing the greetings message HelloReply { string message = 1;}////////////////////////////////////// The greeting service definition. service GreeterService { //////////////////////  // Sends a greeting //  ////////*****/////////  // HELLO //  ////////*****/////////  rpc SayHello (HelloRequest) returns (HelloReply) {} // Comment spanning  // on several lines  rpc ItKeepsTalking (stream HelloRequest) returns (HelloReply) {} /* * C style comments */ rpc ItKeepsReplying (HelloRequest) returns (stream HelloReply) {} /* C style comments * on several lines * with non-empty heading/trailing line */ rpc StreamHellos (stream HelloRequest) returns (stream HelloReply) {} }简单的说明</description>
    </item>
    
    <item>
      <title>Java私有类型装箱拆箱</title>
      <link>http://fantasyplayer.link/program/java%E7%A7%81%E6%9C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</link>
      <pubDate>Thu, 30 Apr 2020 21:27:47 +0800</pubDate>
      
      <guid>http://fantasyplayer.link/program/java%E7%A7%81%E6%9C%89%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</guid>
      <description>简述 在尽可能的情况下， 都应该使用 java的私有类型， 而装箱类型应该少用。
因为 装箱的类型 会占用更多的内存。
内存占用相关的内容    私有类型 装箱类型 内存占用(私有类型/ 装箱类型)     boolean Boolean 1 byte / 16 bytes   byte Byte 1 byte / 16 bytes   short Short 2 bytes / 16 bytes   char Char 2 bytes / 16 bytes   int Integer 4 bytes / 16 bytes   long Long 8 bytes / 16 bytes   float Float 4 bytes / 16 bytes   double Double 8 bytes / 16 bytes     1 byte 是一个字节</description>
    </item>
    
    <item>
      <title>[占位]关于单元测试的一点想法</title>
      <link>http://fantasyplayer.link/program/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</link>
      <pubDate>Thu, 30 Apr 2020 21:27:01 +0800</pubDate>
      
      <guid>http://fantasyplayer.link/program/%E5%85%B3%E4%BA%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%83%B3%E6%B3%95/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>